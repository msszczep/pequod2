
to produce-final-goods
  ask pfs [
    ;;;;;;;;;;;;;;;;calculate divisor;;;;;;;;;;;;;;;;
    let D effort-exponent - k
    foreach intermediate-inputs [set D D + k * input-exponent ?]
    foreach nature-types [set D D + k * nature-exponent ?]
    foreach labor-types [set D D + k * labor-exponent ?]    

    ;;;;;;;;;;;;;;;;set intermediate input demands;;;;;;;;;;;;;;;;
    set input-quantities (list)
    foreach intermediate-inputs [
      let I ?
      let N (- k * (ln A + ln product-price - ln input-price I + ln input-exponent I) )
      let other-inputs remove ? intermediate-inputs
      foreach other-inputs [
        let J ?
        set N N + ( k * input-exponent J * ( ln input-price J - ln input-exponent J - ln input-price I + ln input-exponent I ) )
      ]
      foreach nature-types [
        let J ?
        set N N + ( k * nature-exponent J * ( ln nature-price J - ln nature-exponent J - ln input-price I + ln input-exponent I ) )
      ]
      foreach labor-types [
        let J ?
        set N N + ( k * labor-exponent J * ( ln labor-price J - ln labor-exponent J - ln input-price I + ln input-exponent I ) )
      ]
      set N N + ( effort-exponent * ( ln k + ln S - ln effort-exponent - ln input-price I + ln input-exponent I ) )
      set input-quantities lput exp (N / D) input-quantities
    ]


    ;;;;;;;;;;;;;;;;set nature demands;;;;;;;;;;;;;;;;
    set nature-quantities (list)
    foreach nature-types [
      let I ?
      let N (- k * (ln A + ln product-price - ln nature-price I + ln nature-exponent I) )
      let other-inputs remove ? nature-types
      foreach other-inputs [
        let J ?
        set N N + ( k * nature-exponent J * ( ln nature-price J - ln nature-exponent J - ln nature-price I + ln nature-exponent I ) )
      ]
      foreach intermediate-inputs [
        let J ?
        set N N + ( k * input-exponent J * ( ln input-price J - ln input-exponent J - ln nature-price I + ln nature-exponent I ) )
      ]
      foreach labor-types [
        let J ?
        set N N + ( k * labor-exponent J * ( ln labor-price J - ln labor-exponent J - ln nature-price I + ln nature-exponent I ) )
      ]
      set N N + ( effort-exponent * ( ln k + ln S - ln effort-exponent - ln nature-price I + ln nature-exponent I ) )
      set nature-quantities lput exp (N / D) nature-quantities
    ]

    ;;;;;;;;;;;;;;;;set labor demands;;;;;;;;;;;;;;;;
    set labor-quantities (list)
    foreach labor-types [
      let I ?
      let N (- k * (ln A + ln product-price - ln labor-price I + ln labor-exponent I) )
      let other-inputs remove ? labor-types
      foreach other-inputs [
        let J ?
        set N N + ( k * labor-exponent J * ( ln labor-price J - ln labor-exponent J - ln labor-price I + ln labor-exponent I ) )
      ]
      foreach intermediate-inputs [
        let J ?
        set N N + ( k * input-exponent J * ( ln input-price J - ln input-exponent J - ln labor-price I + ln labor-exponent I ) )
      ]
      foreach nature-types [
        let J ?
        set N N + ( k * nature-exponent J * ( ln nature-price J - ln nature-exponent J - ln labor-price I + ln labor-exponent I ) )
      ]
      set N N + ( effort-exponent * ( ln k + ln S - ln effort-exponent - ln labor-price I + ln labor-exponent I ) )
      set labor-quantities lput exp (N / D) labor-quantities
    ]
    
    set ql labor-quantity 1

    ;;;;;;;;;;;;;;;;set effort;;;;;;;;;;;;;;;;
    let N ( - ln A - ln product-price - ln effort-exponent + ln k + ln S )
    foreach intermediate-inputs [
      let J ?
      set N N + ( input-exponent J * ( ln input-price J - ln input-exponent J + ln effort-exponent - ln k - ln S ) )
    ]
    foreach nature-types [
      let J ?
      set N N + ( nature-exponent J * ( ln nature-price J - ln nature-exponent J + ln effort-exponent - ln k - ln S ) )
    ]
    foreach labor-types [
      let J ?
      set N N + ( labor-exponent J * ( ln labor-price J - ln labor-exponent J + ln effort-exponent - ln k - ln S ) )
    ]
    set effort exp (N / D)

    ;;;;;;;;;;;;;;;;set output;;;;;;;;;;;;;;;;
    let M (- ln A)
    foreach intermediate-inputs [
      let J ?
      set M M + ( input-exponent J * ( ln input-price J - ln input-exponent J - ln product-price ) )
    ]
    foreach nature-types [
      let J ?
      set M M + ( nature-exponent J * ( ln nature-price J - ln nature-exponent J - ln product-price ) )
    ]
    foreach labor-types [
      let J ?
      set M M + ( labor-exponent J * ( ln labor-price J - ln labor-exponent J - ln product-price ) )
    ]
    set M k * M + effort-exponent * ( ln k + ln S - ln effort-exponent - ln product-price )

    set output check-bounds exp (M / D)
    
  ]
end

to produce-input-goods                           
  ask pis [
    let D effort-exponent - k
;    let other-inputs remove product intermediate-inputs
;    foreach other-inputs [set D D + k * input-exponent ?]
    foreach nature-types [set D D + k * nature-exponent ?]
    foreach labor-types [set D D + k * labor-exponent ?]    

;    set input-quantities (list)
;    foreach intermediate-inputs [
;      let I ?
;      ifelse I = product
;        [ set input-quantities lput 0 input-quantities ] 
;        [ let N (- k * (ln A + ln product-price - ln input-price I + ln input-exponent I) )
;;          let other-other-inputs remove ? other-inputs
;;          foreach other-other-inputs [
;;            let J ?
;;            set N N + ( k * input-exponent J * ( ln input-price J - ln input-exponent J - ln input-price I + ln input-exponent I ) )
;;            ]
;          foreach nature-types [
;            let J ?
;            set N N + ( k * nature-exponent J * ( ln nature-price J - ln nature-exponent J - ln input-price I + ln input-exponent I ) )
;            ]
;          foreach labor-types [
;            let J ?
;            set N N + ( k * labor-exponent J * ( ln labor-price J - ln labor-exponent J - ln input-price I + ln input-exponent I ) )
;            ]
;          set N N + ( effort-exponent * ( ln k + ln S - ln effort-exponent - ln input-price I + ln input-exponent I ) )
;        set input-quantities lput exp (N / D) input-quantities
;      ]
;    ]
;    ifelse product = 1 [set qi1 0][set qi1 input-quantity 1]
;    ifelse product = 2 [set qi2 0][set qi2 input-quantity 2]
    set input-quantities (list 0 0)
    
    ;;;;;;;;;;;;;;;;set nature demands;;;;;;;;;;;;;;;;
    set nature-quantities (list)
    foreach nature-types [
      let I ?
      let N (- k * (ln A + ln product-price - ln nature-price I + ln nature-exponent I) )
      let other-natures remove ? nature-types
      foreach other-natures [
        let J ?
        set N N + ( k * nature-exponent J * ( ln nature-price J - ln nature-exponent J - ln nature-price I + ln nature-exponent I ) )
      ]
;      foreach other-inputs [
;        let J ?
;        set N N + ( k * input-exponent J * ( ln input-price J - ln input-exponent J - ln nature-price I + ln nature-exponent I ) )
;      ]
      foreach labor-types [
        let J ?
        set N N + ( k * labor-exponent J * ( ln labor-price J - ln labor-exponent J - ln nature-price I + ln nature-exponent I ) )
      ]
      set N N + ( effort-exponent * ( ln k + ln S - ln effort-exponent - ln nature-price I + ln nature-exponent I ) )
      set nature-quantities lput exp (N / D) nature-quantities
    ]
    

    ;;;;;;;;;;;;;;;;set labor demands;;;;;;;;;;;;;;;;
    set labor-quantities (list)
    foreach labor-types [
      let I ?
      let N (- k * (ln A + ln product-price - ln labor-price I + ln labor-exponent I) )
      let other-labors remove ? labor-types
      foreach other-labors [
        let J ?
        set N N + ( k * labor-exponent J * ( ln labor-price J - ln labor-exponent J - ln labor-price I + ln labor-exponent I ) )
      ]
;      foreach other-inputs [
;        let J ?
;        set N N + ( k * input-exponent J * ( ln input-price J - ln input-exponent J - ln labor-price I + ln labor-exponent I ) )
;      ]
      foreach nature-types [
        let J ?
        set N N + ( k * nature-exponent J * ( ln nature-price J - ln nature-exponent J - ln labor-price I + ln labor-exponent I ) )
      ]
      set N N + ( effort-exponent * ( ln k + ln S - ln effort-exponent - ln labor-price I + ln labor-exponent I ) )
      set labor-quantities lput exp (N / D) labor-quantities
    ]
    
    set ql labor-quantity 1

    ;;;;;;;;;;;;;;;;set effort;;;;;;;;;;;;;;;;
    let N ( - ln A - ln product-price - ln effort-exponent + ln k + ln S )
;    foreach other-inputs [
;      let J ?
;      set N N + ( input-exponent J * ( ln input-price J - ln input-exponent J + ln effort-exponent - ln k - ln S ) )
;    ]
    foreach nature-types [
      let J ?
      set N N + ( nature-exponent J * ( ln nature-price J - ln nature-exponent J + ln effort-exponent - ln k - ln S ) )
    ]
    foreach labor-types [
      let J ?
      set N N + ( labor-exponent J * ( ln labor-price J - ln labor-exponent J + ln effort-exponent - ln k - ln S ) )
    ]
    set effort exp (N / D)

    ;;;;;;;;;;;;;;;;set output;;;;;;;;;;;;;;;;
    let M (- ln A)
;    foreach other-inputs [
;      let J ?
;      set M M + ( input-exponent J * ( ln input-price J - ln input-exponent J - ln product-price ) )
;    ]
    foreach nature-types [
      let J ?
      set M M + ( nature-exponent J * ( ln nature-price J - ln nature-exponent J - ln product-price ) )
    ]
    foreach labor-types [
      let J ?
      set M M + ( labor-exponent J * ( ln labor-price J - ln labor-exponent J - ln product-price ) )
    ]
    set M k * M + effort-exponent * ( ln k + ln S - ln effort-exponent - ln product-price )

    set output check-bounds exp (M / D)

  ]
end
